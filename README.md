# KSP Companion

This program is designed to be used alongside the game Kerbal Space Program (KSP). Personally, when I played the game and used trial-and-error to find successful designs, I felt a bit like I was cheating. I wanted to play the game with the same stakes as a real space agency. You have to know before launch that your rocket is big enough, but you can't just waste resources when it comes to expensive rocketry. The goal is that it should be possible for a player to launch a mission with full confidence that the spacecraft they've built will be able to complete all the mission objectives - without unnecessary waste. This first prototype allows for the planning of a basic mission around the game's home planet Kerbin, and has all the core mechanisms needed for a final mission design tool.

## For Employers
This project has been significantly larger in scale and complexity compared to my previous coding experiences, and has taught me several valuable lessons in software design and engineering. From the start I had to spend time thinking about how the program would be structured, and I looked into different software design tools such as UML to help me make sense of what the goals of the program were, and how they could be achieved. 
This process also inspired me to read "A Philosophy Of Software Design" by Ousterhout for some guidance and a framework to assess the choices I made in the design. Even though I knew I would be the sole developer, I felt that it would be best if I coded this project as though other developers could come along and have to build on top of my work without prior experience in orbital mechanics or my code. 

As I worked on early designs of the tool it became clear that some classes, primarily the Orbit and Anglef/d classes, would be more important to the program's operation than others, and so I paid special attention to ensure I built those classes with a deliberate mindset. 
For example, the Orbit class was built to represent an object in an orbit around a gravitational body. Mathematically, orbits have many constant geometric properties as well as lots of dynamic information that it can be very useful to calculate. Knowing how crucial this class would be, and knowing that it represented something quite challenging and complex, I put a lot of effort into building this class to well tested, well documented, and made with clear and descriptive identifiers throughout. The goal was to minimise the cognitive-load needed for a new developer to use the class, while still providing all the crucial data needed by other modules in the program. 
Ideally many more classes in the program would have received a similar level of attention, but I was cautious to apply such focus to aspects I knew were likely to evolve dramatically, and I thought it best for my learning to practise applying good design principles to a small and manageable area, with the intention of starting a good habit to take forward to later projects.

Despite the attention I paid to trying build a good design, there are still several things I would do differently when working on this project in the future. An aspect of the program that I think really needs a re-do is the MissionTimeline class and the related TimelineStep class hierarchy. 
The MissionTimeline class has had many ad-hoc solutions injected into it and as a result is a bit of a Frankenstein's monster, with clear violation of the first principle of SOLID OOP. Luckily I found the ugliness didn't spread too far beyond the class so I was happy to let it go for the sake of saving time. 
The TimelineStep class hierarchy includes classes for representing the many different kinds of event that could occur when planning a mission. The resulting structure was again the result of some ad-hoc problem solving, and I think a cleaner and more extensible design would be possible. 
Despite the issues, I'm glad for the experience of having to work with these classes and their problems for the sake of understanding the motivation for often repeated programming principles such as SOLID.

The completion of this project demonstrated through experience some software engineering principles that I have read about in books and articles around the web. I found that a small misalignment between the interface of a class and the abstraction the class is meant to represent could lead to unnecessarily complex problems arising in other modules when they try to use the class. 
I also discovered the joy of proper testing during this project - this is something I found a bit of a chore when I first explored it but by the end I loved the confidence that my testing provided. 
I could make similar remarks on the writing of comments - by the end I enjoyed the experience of knowing my work in documenting effectively would pay off later when working with the code again later. 
The skills I practised during this project are something I'd love to keep working on, especially in a real collaborative environment. 

## Credits:
* Most of the orbital mechanics knowledge was learned from Prussing and Conway's Orbital Mechanics textbook, and from [this](http://braeunig.us/space/index_top.htm) website.
* I am deeply indebted to [this](https://www.esa.int/gsp/ACT/doc/MAD/pub/ACT-RPR-MAD-2014-RevisitingLambertProblem.pdf) paper by Izzo for an algorithm for solving [Lambert's problem](https://en.wikipedia.org/wiki/Lambert's_problem).
* Many of the nice UI icons are from RainbowArt's [Clean Flat Icons](https://assetstore.unity.com/packages/2d/gui/icons/clean-flat-icons-98117) asset pack.
* The nice 3D spheres and lines use Freya Holm√©r's [Shapes](https://assetstore.unity.com/packages/tools/particles-effects/shapes-173167) asset pack.
